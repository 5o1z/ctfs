/* This file was generated by the Hex-Rays decompiler version 9.2.0.250908.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 (**init_proc())(void);
void JUMPOUT_w();
void JUMPOUT_ww();
void JUMPOUT_ww_0();
void JUMPOUT_ww_1();
void JUMPOUT_ww_2();
void JUMPOUT_ww_3();
void JUMPOUT_ww_4();
void JUMPOUT_ww_5();
void JUMPOUT_ww_6();
void JUMPOUT_ww_7();
void JUMPOUT_ww_8();
void JUMPOUT_ww_9();
void JUMPOUT_ww_10();
void JUMPOUT_ww_11();
void JUMPOUT_ww_12();
void JUMPOUT_ww_13();
void JUMPOUT_ww_14();
FILE **deregister_tm_clones();
__int64 register_tm_clones(void); // weak
FILE **_do_global_dtors_aux();
__int64 frame_dummy(); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
void term_proc();
// int _libc_start_main(int (*main)(int, char **, char **), int argc, char **ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)(), void *stack_end);
// int __cxa_finalize(void *);
// __int64 _gmon_start__(void); weak

//-------------------------------------------------------------------------
// Data declarations

// extern _UNKNOWN _cxa_finalize;
void *_dso_handle = &_dso_handle; // idb
FILE *stdout; // idb
char completed_0; // weak


//----- (0000000000001000) ----------------------------------------------------
// Alternative name is '_init'
__int64 (**init_proc())(void)
{
  __int64 (**__gmon_start_)(void); // rax

  __gmon_start_ = &_gmon_start__;
  if ( &_gmon_start__ )
    return (__int64 (**)(void))_gmon_start__();
  return __gmon_start_;
}
// 40D0: using guessed type __int64 _gmon_start__(void);

//----- (0000000000001020) ----------------------------------------------------
void sub_1020()
{
  JUMPOUT(0);
}
// 1026: control flows out of bounds to 0

//----- (0000000000001030) ----------------------------------------------------
void sub_1030()
{
  JUMPOUT_w();
}

//----- (0000000000001040) ----------------------------------------------------
void sub_1040()
{
  JUMPOUT_w();
}

//----- (0000000000001050) ----------------------------------------------------
void sub_1050()
{
  JUMPOUT_w();
}

//----- (0000000000001060) ----------------------------------------------------
void sub_1060()
{
  JUMPOUT_w();
}

//----- (0000000000001070) ----------------------------------------------------
void sub_1070()
{
  JUMPOUT_w();
}

//----- (0000000000001080) ----------------------------------------------------
void sub_1080()
{
  JUMPOUT_w();
}

//----- (0000000000001090) ----------------------------------------------------
void sub_1090()
{
  JUMPOUT_w();
}

//----- (00000000000010A0) ----------------------------------------------------
void sub_10A0()
{
  JUMPOUT_w();
}

//----- (00000000000010B0) ----------------------------------------------------
void sub_10B0()
{
  JUMPOUT_w();
}

//----- (00000000000010C0) ----------------------------------------------------
void sub_10C0()
{
  JUMPOUT_w();
}

//----- (00000000000010D0) ----------------------------------------------------
void sub_10D0()
{
  JUMPOUT_w();
}

//----- (00000000000010E0) ----------------------------------------------------
void sub_10E0()
{
  JUMPOUT_w();
}

//----- (00000000000010F0) ----------------------------------------------------
void sub_10F0()
{
  JUMPOUT_w();
}

//----- (0000000000001100) ----------------------------------------------------
void sub_1100()
{
  JUMPOUT_w();
}

//----- (0000000000001110) ----------------------------------------------------
void sub_1110()
{
  JUMPOUT_w();
}

//----- (0000000000001120) ----------------------------------------------------
void sub_1120()
{
  JUMPOUT_w();
}

//----- (0000000000001240) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*rtld_fini)())
{
  __int64 stack_end__1; // rax
  int argc; // esi
  __int64 stack_end_; // [rsp-8h] [rbp-8h] BYREF
  char *ubp_av_; // [rsp+0h] [rbp+0h] BYREF

  argc = stack_end_;
  stack_end_ = stack_end__1;
  _libc_start_main((int (*)(int, char **, char **))main, argc, &ubp_av_, 0, 0, rtld_fini, &stack_end_);
  __halt();
}
// 124A: positive sp value 8 has been found
// 1251: variable 'v3' is possibly undefined

//----- (0000000000001270) ----------------------------------------------------
FILE **deregister_tm_clones()
{
  return &stdout;
}

//----- (00000000000012A0) ----------------------------------------------------
__int64 register_tm_clones()
{
  return 0;
}
// 12A0: using guessed type __int64 register_tm_clones();

//----- (00000000000012E0) ----------------------------------------------------
FILE **_do_global_dtors_aux()
{
  FILE **result; // rax

  if ( !completed_0 )
  {
    if ( &__cxa_finalize )
      _cxa_finalize(_dso_handle);
    result = deregister_tm_clones();
    completed_0 = 1;
  }
  return result;
}
// 4028: using guessed type char completed_0;

//----- (0000000000001320) ----------------------------------------------------
__int64 frame_dummy()
{
  return register_tm_clones();
}
// 12A0: using guessed type __int64 register_tm_clones(void);
// 1320: using guessed type __int64 frame_dummy();

//----- (0000000000001329) ----------------------------------------------------
__int64 __fastcall get_loc(int n7)
{
  return 0x200000;
}

//----- (000000000000133E) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // rsi
  int i; // [rsp+0h] [rbp-110h]
  int j; // [rsp+4h] [rbp-10Ch]
  __int64 k; // [rsp+8h] [rbp-108h]
  __int64 v8; // [rsp+10h] [rbp-100h]
  void *addr; // [rsp+18h] [rbp-F8h]
  int choice; // [rsp+20h] [rbp-F0h]
  int index[17]; // [rsp+24h] [rbp-ECh] BYREF
  char seed[128]; // [rsp+68h] [rbp-A8h] BYREF
  int prot; // [rsp+E8h] [rbp-28h]
  void (__fastcall *v14)(__int64, __int64); // [rsp+F0h] [rbp-20h]
  unsigned __int64 v15; // [rsp+F8h] [rbp-18h]

  v15 = __readfsqword(0x28u);
  setbuf(stdout, 0);
  v8 = seccomp_init(2147418112);
  if ( !v8 )
  {
    perror("seccomp_init");
    exit(1);
  }
  if ( (int)seccomp_rule_add(v8, 327681, 59, 0) < 0 )
  {
    perror("seccomp_rule_add for execve");
    seccomp_release(v8);
    exit(1);
  }
  if ( (int)seccomp_rule_add(v8, 327681, 322, 0) < 0 )
  {
    perror("seccomp_rule_add for execveat");
    seccomp_release(v8);
    exit(1);
  }
  if ( (int)seccomp_load(v8) < 0 )
  {
    perror("seccomp_load");
    seccomp_release(v8);
    exit(1);
  }
  prot = 3;
  while ( 1 )
  {
    puts("Welcome to GadgetFreak!");
    puts("1. Get Gadget");
    puts("2. Set Seed");
    puts("3. Exit");
    puts("Enter your choice: ");
    choice = fgetc(stdin) - 48;
    fgetc(stdin);
    if ( choice == 7 )
    {
      v4 = (unsigned int)index[0];
      get_loc(7);
      v14(7, v4);                               // Call something
      goto LABEL_37;
    }
    if ( choice > 7 )
      goto LABEL_37;
    if ( choice == 3 )
      break;
    if ( choice > 3 )
      goto LABEL_37;
    if ( choice == 1 )                          // Get Gadget
    {
      if ( seed[0] )
      {
        puts("Enter gadget index (0-9): ");
        __isoc99_scanf("%d\n", index);
        if ( index[0] >= 16u )
        {
          puts("Invalid gadget index!");
        }
        else
        {
          printf("Your gadget: %d\n", index[index[0] + 1]);
          if ( index[0] == '\a' && index[8] == '*' )
            puts("You found the hidden gadget! Congratulations!");
        }
      }
      else
      {
        puts("Please set a seed first!");
      }
    }
    else if ( choice == 2 )                     // Set seed
    {
      puts("Enter seed (up to 128 characters): ");
      fgets(seed, 148, stdin);                  // Stack Overflow
      addr = (void *)get_loc(2);                // addr = 0x200000
      mmap(addr, 0x1000u, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANON, -1, 0);
      memcpy(addr, seed, 0x1000u);
      for ( i = 0; i <= 15; ++i )
      {
        index[i + 1] = 0;
        for ( j = i; j < strlen(seed); j += 16 )
          index[i + 1] += seed[j];
      }
      mmap((void *)0x300000, 0x40000u, (ENUM_PROT)prot, MAP_SHARED|MAP_ANON, -1, 0);
      for ( k = 0; k <= 0xFFFF; ++k )
        *(_DWORD *)(4 * (k + 0xC0000)) = k;
      puts("Seed set successfully!");
    }
    else
    {
LABEL_37:
      puts("Invalid choice. Please try again.");
    }
  }
  puts("Thank you for using GadgetFreak!");
  return 0;
}
// 1170: using guessed type __int64 __fastcall seccomp_load(_QWORD);
// 11D0: using guessed type __int64 __fastcall seccomp_release(_QWORD);

//----- (000000000000181C) ----------------------------------------------------
// Alternative name is '_fini'
void term_proc()
{
  ;
}

// nfuncs=62 queued=26 decompiled=26 lumina nreq=0 worse=0 better=0
// ALL OK, 26 function(s) have been successfully decompiled
